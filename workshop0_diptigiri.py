# -*- coding: utf-8 -*-
"""Workshop0_DiptiGiri.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AO9ogxSNEDWVUPqQ0GVW2dq4bsp4nJnc
"""

#task 1
# Daily time data (already provided)
time_data = [
(3.5, 2.0, 7.0), (5.0, 1.5, 6.5), (2.5, 3.0, 8.0),
(4.0, 2.0, 6.0), (1.5, 4.5, 9.0), (3.0, 2.5, 7.5),
(5.5, 1.0, 6.0), (2.0, 3.5, 8.5), (4.5, 2.0, 7.0),
(3.0, 3.0, 7.5), (6.0, 1.5, 6.0), (2.5, 4.0, 8.0),
(4.0, 2.5, 7.0), (5.0, 2.0, 6.5), (3.5, 2.5, 7.0)
]
low = []
moderate = []
high = []

for study, ent, sleep in time_data:
    if study < 3:
        low.append(study)
    elif 3 <= study <= 5:
        moderate.append(study)
    else:
        high.append(study)

print("Low Study Hours:", low)
print("Moderate Study Hours:", moderate)
print("High Study Hours:", high)

#Task 2
print("Low study days:", len(low))
print("Moderate study days:", len(moderate))
print("High study days:", len(high))

#Task 3
study_minutes = []

for study, ent, sleep in time_data:
    study_minutes.append(study * 60)

print("Study minutes:", study_minutes)

#Task 4
study_hours = []
entertainment_hours = []
sleep_hours = []

for study, ent, sleep in time_data:
    study_hours.append(study)
    entertainment_hours.append(ent)
    sleep_hours.append(sleep)

avg_study = sum(study_hours) / len(study_hours)
avg_ent = sum(entertainment_hours) / len(entertainment_hours)
avg_sleep = sum(sleep_hours) / len(sleep_hours)

print("Average Study Hours:", avg_study)
print("Average Entertainment Hours:", avg_ent)
print("Average Sleep Hours:", avg_sleep)

#Task 5
import matplotlib.pyplot as plt

study_hours = [d[0] for d in time_data]
sleep_hours = [d[2] for d in time_data]

plt.scatter(study_hours, sleep_hours, color='purple')
plt.xlabel("Study Hours")
plt.ylabel("Sleep Hours")
plt.title("Study vs Sleep Pattern")
plt.grid(True)
plt.show()

#Section 8-Task 1
def sum_nested_list(nested_list):
    total = 0
    for element in nested_list:
        if isinstance(element, list):
            total += sum_nested_list(element)
        else:
            total += element
    return total

# Test
nested_list = [1, [2, [3, 4], 5], 6, [7, 8]]
print(sum_nested_list(nested_list))

#Task 2
def generate_permutations(s):
    if len(s) == 1:
        return [s]

    perms = []
    for i in range(len(s)):
        ch = s[i]
        rest = s[:i] + s[i+1:]
        for p in generate_permutations(rest):
            perms.append(ch + p)

    return list(set(perms))  # Remove duplicates

print(generate_permutations("abc"))

#Task 3
def calculate_directory_size(directory):
    total = 0
    for name, item in directory.items():
        if isinstance(item, dict):
            total += calculate_directory_size(item)
        else:
            total += item
    return total

# Provided data
directory_structure = {
    "file1.txt": 200,
    "file2.txt": 300,
    "subdir1": {
        "file3.txt": 400,
        "file4.txt": 100
    },
    "subdir2": {
        "subsubdir1": {
            "file5.txt": 250
        },
        "file6.txt": 150
    }
}

print(calculate_directory_size(directory_structure))

#section 8.2-task 1
def min_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i-coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1

print(min_coins([1,2,5], 11))

#Task 2
def longest_common_subsequence(s1, s2):
    n, m = len(s1), len(s2)
    dp = [[0]*(m+1) for _ in range(n+1)]

    for i in range(1,n+1):
        for j in range(1,m+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = 1 + dp[i-1][j-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[n][m]

print(longest_common_subsequence("abcde","ace"))

#Task 3
def knapsack(weights, values, capacity):
    n = len(weights)
    dp = [[0]*(capacity+1) for _ in range(n+1)]

    for i in range(1, n+1):
        w = weights[i-1]
        val = values[i-1]
        for c in range(1, capacity+1):
            if w <= c:
                dp[i][c] = max(dp[i-1][c], dp[i-1][c-w] + val)
            else:
                dp[i][c] = dp[i-1][c]

    return dp[n][capacity]

print(knapsack([1,3,4,5], [1,4,5,7], 7))

